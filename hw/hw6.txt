Nat_ops.

type nat = Zero | S of nat
module Nat_ops =

struct
  let rec nat_of_int i =
    if i <= 0 then Zero
    else S (nat_of_int (i-1))
  let rec int_of_nat n =
    match n with
    | Zero -> 0
    | S m -> 1 + (int_of_nat m)
  let rec plus a b =
    match b with
    | Zero -> a
    | S c -> plus (S a) c
end

-----------------------------------------------------------------------------------------------

P1) Prove plus Zero b = b
Base case: b = Zero
Show: plus Zero Zero = Zero

    plus Zero b 
= { case }
    plus Zero Zero 
= { def plus }
    let rec plus a b =
        match Zero with
        | Zero -> a
        | S c -> plus (S a) c
= { apply match }
    a
= { case }
    Zero

Induction step: b = S n
Induction hypothesis (IH): plus Zero (S n) = S n

    plus Zero b 
= { case }
    plus Zero (S n)
= { plus def }
    let rec plus a b =
        match (S n) with
        | Zero -> a
        | S c -> plus (S a) c
= { apply match }
    plus (S Zero) n
= { plus def }
    let rec plus a b =
        match n with
        | Zero -> a
        | S c -> plus (S a) c
= { apply match }
    (S Zero)
= { IS }
    S b 
= { case }
    S n



P2) Prove plus a b = plus b a
Base case: Given any a = S n, prove that for b = Zero statement holds true

    plus a b 
= { case }
    plus (S n) Zero
= { plus def }
    let rec plus a b =
        match Zero with
        | Zero -> a
        | S c -> plus (S a) c
= { apply match }
    a
= { case }
    (S n)
= { apply reverse match }


    plus a b 
= { case }
    plus Zero (S n)
= { plus def }
    let rec plus a b =
        match (S n) with
        | Zero -> a
        | S c -> plus (S a) c
= { apply match }
    plus (S Zero) n
= { plus def }
    let rec plus a b =
        match n with
        | Zero -> a
        | S c -> plus (S a) c
= { apply match }
    (S Zero)
= { case }
    S n


Induction: Given any a, assume statement holds for b. Show for S b
IH: for all a = n, plus n b = plus b n


= ...
plus (S a) b
= {IH}
plus b (S a)
= ...


P3) Prove plus a (plus b c) = plus (plus a b) c